<div class="hero-unit">
    <h1>Core Features</h1>

    <p class="pull-right">Elementary entities manipulated in Kevoree models</p>
</div>

<!-- Common Type Definition -->
<div class="row">
    <div class="span2 heading-box">
        <h3>TypeDefinition</h3>
    </div>
    <div class="span6">
        <h4>TypeDefinition/Instance separation</h4>

        <p>Every Kevoree features follow a type/instance design pattern. Similarly to Class and Object separationin OO
            programmation, Kevoree type definitions define <code>what</code> is available in the system while instances
            define <code>how/where</code> each functionality is used.</p>
    </div>
</div>
<hr/>


<!-- Dictionary Definition -->
<div class="row">
    <div class="span2 heading-box">
        <h3>Dictionary</h3>
    </div>
    <div class="span4">
        <h4>Dictionaries define parameters</h4>

        <p>Each type may define a DictionaryType that identify the set of potential parameters. These parameters are
            then defined when an instance is created.
        </p>
        <!-- TODO INSERT FIGURE -->

    </div>
    <div class="span6">

        <!-- Model Example -->
        <pre class="code-box prettyprint">
@NodeType
@DictionaryType({
    @DictionaryAttribute(name = "logLevel",
            defaultValue = "INFO", optional = true,
            vals = {"INFO","WARN","DEBUG","ERROR"})
})
public class JavaSENode extends AbstractNodeType {
}</pre>
    </div>
</div>

<hr/>


<!-- Component Definition -->
<div class="row">
    <div class="span2 heading-box">
        <h3>Component</h3>
    </div>
    <div class="span4">
        <h4>Components encapsulate business functionalities</h4>

        <p>Each component provides a set of functionalities exposed to others. A component also requires functionalities
            to achieve their own ones. All these functionalities are
            identified by a port (required or provided) on the component.</p>

        <p>Components communicates only through their ports.</p>

        <p></p>
    </div>
    <div class="span6">
        <pre class="code-box prettyprint">
@ComponentType
public class FakeConsole
            extends AbstractComponentType {
}</pre>
    </div>
</div>
<hr/>

<!-- Channel Definition -->
<div class="row">
    <div class="span2 heading-box">
        <h3>Channel</h3>
    </div>
    <div class="span4">
        <h4>Channel entity encapsulate business communication semantics</h4>

        <p>An application also defines how components are bound to exchange data. These bindings are done with channels
            that encapsulate inter-component communication semantics. For instance such
            channel semantics can encapsulate broadcast diffusion or distributed transaction, etc.
        </p>
        <!-- TODO INSERT FIGURE -->

    </div>
    <div class="span6">
        <!-- Model Example -->
        <pre class="code-box prettyprint">
@ChannelTypeFragment
public class defMSG extends AbstractChannelFragment {
}</pre>
    </div>
</div>

<hr/>

<!-- Node Definition -->
<div class="row">
    <div class="span2 heading-box">
        <h3>Node</h3>
    </div>
    <div class="span4">
        <h4>Nodes encapsulate adaptation semantics</h4>

        <p>Distributed systems are composed by computation node instances related to a NodeType. A NodeType host
            specific adaptation semantics which is composed by a list of managed AdaptationPrimitive types and a
            planning algorithm</p>
        <!-- TODO INSERT FIGURE -->

    </div>
    <div class="span6">

        <!-- Model Example -->
        <pre class="code-box prettyprint">
@NodeType
public class JavaSENode extends AbstractNodeType {
}</pre>
    </div>
</div>

<hr/>

<!-- Group Definition -->
<div class="row">
    <div class="span2 heading-box">
        <h3>Groups</h3>
    </div>
    <div class="span4">
        <h4>Groups encapsulate node synchronisation and communication semantic</h4>

        <p>In a nutshell, groups are channels dedicated to inter-nodes communications. These entity encapsulate also
            synchronisation semantics such as groups synchronisation in total or partial order,
            etc ....</p>
        <!-- TODO INSERT FIGURE -->
    </div>
    <div class="span6">
        <!-- Model Example -->
        <pre class="code-box prettyprint">
@ChannelTypeFragment
public class GossiperGroup extends AbstractGroupType {
}</pre>
    </div>
</div>

<hr/>


<!-- Adaptation -->
<div class="row">
    <div class="span2 heading-box">
        <h3>Adaptation Primitive</h3>
    </div>
    <div class="span4">
        <h4>Adaptation primitives define adaptation capabilities for a NodeType</h4>

        <p>A node instance can be viewed as a container which provides an isolation level and has responsibility to
            ensure the synchronization between model and runtime. This responsibility is
            represented by the adaptation capabilities the node has and these adaptation capabilities are provided by
            adaptation primitives to perform migration actions between two configurations (two
            models).
        </p>
        <!-- TODO INSERT FIGURE -->

    </div>
    <div class="span6">

        <!-- Model Example -->
        <pre class="code-box prettyprint">
@NodeType
@PrimitiveCommands(
    values = {"UpdateType", "UpdateDeployUnit", "AddType", "AddDeployUnit",
            "AddThirdParty", "RemoveType", "RemoveDeployUnit",
            "UpdateInstance", "UpdateBinding", "UpdateDictionaryInstance",
            "AddInstance", "RemoveInstance", "AddBinding",
            "RemoveBinding", "AddFragmentBinding", "RemoveFragmentBinding",
            "UpdateFragmentBinding", "StartInstance",
            "StopInstance", "StartThirdParty","RemoveThirdParty"})
public class JavaSENode extends AbstractNodeType {
}</pre>
    </div>
</div>

<hr/>

<!-- DeployUnit and ThirdParties -->
<div class="row">
    <div class="span2 heading-box">
        <h3>DeployUnits and ThirdParty</h3>
    </div>
    <div class="span4">
        <h4>DeployUnits are provisioning units</h4>

        <p>Each type (component, channel, node, group) may use third party dependencies that must be installed on the
            platform to allow the instances to run. These dependencies are expressed by
            DeployUnit that represent a provisioning unit</p>
        <!-- TODO INSERT FIGURE -->

    </div>
    <div class="span6">

        <!-- Model Example -->
        <pre class="code-box prettyprint">
TODO
</pre>
    </div>
</div>

<hr/>